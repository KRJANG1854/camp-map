<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
  <title>iOS 터치 안정판 v2 - 사진 라벨러</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b0b0b; color:#f5f5f5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', Arial, sans-serif; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }
    header, footer { padding: 8px 10px; background: #121212; border-bottom: 1px solid #222; }
    footer { border-top: 1px solid #222; border-bottom: none; display:flex; gap:8px; flex-wrap: wrap; align-items:center; }
    button, .pill {
      background:#1f1f1f; color:#eee; border:1px solid #333; padding:10px 12px; border-radius:12px; font-size:14px;
      touch-action: manipulation;
    }
    button:active { transform: scale(0.98); }
    #canvasWrap { position: relative; overflow:hidden; background:#000; }
    canvas { position:absolute; left:0; top:0; touch-action:none; }
    #hud { position:absolute; left:8px; top:8px; display:flex; gap:8px; z-index:6; }
    .panel {
      position:absolute; z-index:7; left:8px; right:8px; bottom:64px;
      background:#141414; border:1px solid #2a2a2a; border-radius:14px; padding:10px; display:none;
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    .panel.open { display:block; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    .chip { background:#1f1f1f; border:1px solid #333; border-radius:999px; padding:8px 12px; cursor:pointer; }
    .chip.active { background:#2d4dff; border-color:#5873ff; }
    #toast {
      position: absolute; left: 50%; top: 12px; transform: translateX(-50%);
      background: rgba(20,20,20,.9); border:1px solid #333; color:#fff; padding:8px 12px; border-radius:12px;
      z-index:9; display:none; white-space:nowrap;
    }
    input[type="file"] { display:none; }
    label.file { background:#1f1f1f; border:1px dashed #444; padding:10px 12px; border-radius:12px; cursor:pointer; }
    .spacer { flex:1 1 auto; }
    .muted { color:#bdbdbd; font-size:12px; }
    .danger { background:#3a1111; border-color:#6b1c1c; }
    .ok { background:#12331a; border-color:#1f6b36; }
    .warn { background:#332a12; border-color:#6b5a1c; }
    a.link { color:#9ecaff; text-decoration: underline; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
      <label for="bgFile" class="file">사진 불러오기</label>
      <input id="bgFile" type="file" accept="image/*" />
      <button id="btnDate">날짜</button>
      <button id="btnFeature">기능</button>
      <span class="pill muted">두 손가락 핀치 / 한 손가락 드래그</span>
      <div class="spacer"></div>
      <span id="status" class="muted"></span>
    </div>
  </header>
  <div id="canvasWrap">
    <canvas id="stage" width="1920" height="1080"></canvas>
    <div id="hud">
      <span class="pill" id="currentMode">라벨: (없음)</span>
      <span class="pill" id="deleteMode">개별삭제: OFF</span>
    </div>
    <div id="panelDate" class="panel">
      <div class="row" id="weekdayRow"></div>
      <div class="muted" style="margin-top:8px">요일을 고르면 패널이 닫히고, 지도(사진)를 한 번 탭하면 라벨이 찍힙니다.</div>
    </div>
    <div id="panelFeature" class="panel">
      <div class="row" style="margin-bottom:8px">
        <button id="toggleDelete" class="warn">개별삭제 ON/OFF</button>
        <button id="resetView">뷰 초기화</button>
        <button id="clearAll" class="danger">모두 삭제</button>
      </div>
      <div class="row" style="margin-bottom:8px">
        <button id="exportPng" class="ok">PNG 저장</button>
        <button id="exportJson">JSON 내보내기</button>
        <button id="importJson">JSON 가져오기</button>
      </div>
      <div class="muted">* iOS: 더블탭 확대 방지됨. 핀치는 ‘손가락 중간점’ 기준으로 확대/축소됩니다.</div>
    </div>
    <div id="toast"></div>
  </div>
  <footer>
    <span class="muted">팁: 날짜(예: 토)를 선택하면 패널이 자동으로 닫히고, 다음 탭에 라벨이 찍혀요. 개별삭제는 기능 탭에서 ON 후 라벨을 가볍게 탭.</span>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('canvasWrap');
  const panelDate = document.getElementById('panelDate');
  const panelFeature = document.getElementById('panelFeature');
  const btnDate = document.getElementById('btnDate');
  const btnFeature = document.getElementById('btnFeature');
  const weekdayRow = document.getElementById('weekdayRow');
  const currentMode = document.getElementById('currentMode');
  const deleteModePill = document.getElementById('deleteMode');
  const statusEl = document.getElementById('status');
  const toast = document.getElementById('toast');

  const bgFile = document.getElementById('bgFile');
  const toggleDeleteBtn = document.getElementById('toggleDelete');
  const resetViewBtn = document.getElementById('resetView');
  const clearAllBtn = document.getElementById('clearAll');
  const exportPngBtn = document.getElementById('exportPng');
  const exportJsonBtn = document.getElementById('exportJson');
  const importJsonBtn = document.getElementById('importJson');

  const WEEKDAYS = ['월', '화', '수', '목', '금', '토', '일'];
  const stateKey = 'photo-labeller-v2:' + location.pathname + location.search;

  // World (image) space
  let img = new Image();
  let imgLoaded = false;
  let worldW = 1920, worldH = 1080;

  // Labels in world coordinate
  let labels = []; // {id, text, x, y}

  // View transform (world -> screen)
  let scale = 1, translateX = 0, translateY = 0;
  const MIN_SCALE = 0.2, MAX_SCALE = 8;

  // Interaction
  let isPanning = false;
  let lastTouch = null;
  let pinch = null;
  let pendingLabel = null; // '월'..'일' or null
  let deleteMode = false;
  let lastTapTime = 0;
  let tapCandidate = null;

  function showToast(msg, ms=1200) {
    toast.textContent = msg;
    toast.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.style.display='none', ms);
  }

  function openPanel(p) {
    panelDate.classList.remove('open');
    panelFeature.classList.remove('open');
    if (p) p.classList.add('open');
  }
  function closePanels() { openPanel(null); }

  // Weekday chips
  WEEKDAYS.forEach(d => {
    const el = document.createElement('span');
    el.className = 'chip';
    el.textContent = d;
    el.addEventListener('click', () => {
      pendingLabel = d;
      updateModePill();
      closePanels();
      showToast(`라벨: ${d} 선택. 지도를 탭해 배치하세요.`);
    });
    weekdayRow.appendChild(el);
  });

  function updateModePill() {
    currentMode.textContent = '라벨: ' + (pendingLabel || '(없음)');
    deleteModePill.textContent = '개별삭제: ' + (deleteMode ? 'ON' : 'OFF');
  }

  // File load
  bgFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    await loadImage(url);
    URL.revokeObjectURL(url);
    fitView();
    render();
    save();
  });

  function loadImage(src) {
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.onload = () => {
        img = im;
        imgLoaded = true;
        worldW = im.naturalWidth;
        worldH = im.naturalHeight;
        // Resize canvas to container size (device pixels)
        resizeCanvas();
        resolve();
      };
      im.onerror = reject;
      im.src = src;
    });
  }

  // Resize canvas to match container CSS pixel size but keep device pixel ratio
  function resizeCanvas() {
    const rect = wrap.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener('resize', () => { resizeCanvas(); render(); });

  function setStatus() {
    statusEl.textContent = imgLoaded ? `${Math.round(scale*100)}%` : '사진 미선택';
  }

  function fitView() {
    if (!imgLoaded) return;
    const rect = wrap.getBoundingClientRect();
    const sX = rect.width / worldW;
    const sY = rect.height / worldH;
    scale = Math.min(sX, sY);
    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
    const worldToScreen = (x,y)=>[x*scale + translateX, y*scale + translateY];
    // center
    translateX = (rect.width - worldW*scale)/2 * (window.devicePixelRatio||1) / (window.devicePixelRatio||1);
    translateY = (rect.height - worldH*scale)/2 * (window.devicePixelRatio||1) / (window.devicePixelRatio||1);
  }

  function worldToScreen(pt) {
    return { x: pt.x * scale + translateX, y: pt.y * scale + translateY };
  }
  function screenToWorld(pt) {
    return { x: (pt.x - translateX) / scale, y: (pt.y - translateY) / scale };
  }

  function clamp(val, lo, hi) { return Math.max(lo, Math.min(hi, val)); }

  function render() {
    const dpr = window.devicePixelRatio || 1;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);

    ctx.save();
    ctx.scale(dpr, dpr);

    // draw background
    if (imgLoaded) {
      // We draw with current transform (scale/translate in CSS pixel space)
      ctx.setTransform(scale, 0, 0, scale, translateX, translateY);
      ctx.drawImage(img, 0, 0);
    }

    // draw labels
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    if (labels.length) {
      for (const L of labels) {
        const s = worldToScreen({x:L.x, y:L.y});
        drawLabel(s.x, s.y, L.text);
      }
    }

    ctx.restore();
    setStatus();
  }

  function drawLabel(x, y, text) {
    ctx.save();
    ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont, Roboto, "Noto Sans KR", Arial';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    // bubble
    const padX = 8, padY = 6;
    const w = ctx.measureText(text).width + padX*2;
    const h = 26;
    const r = 12;
    const left = x - w/2, top = y - h/2;

    ctx.beginPath();
    const right = left + w, bottom = top + h;
    ctx.moveTo(left+r, top);
    ctx.arcTo(right, top, right, bottom, r);
    ctx.arcTo(right, bottom, left, bottom, r);
    ctx.arcTo(left, bottom, left, top, r);
    ctx.arcTo(left, top, right, top, r);
    ctx.closePath();
    ctx.fillStyle = 'rgba(13, 110, 253, 0.9)';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.stroke();

    // text
    ctx.fillStyle = '#fff';
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  // ---------- Interaction (touch) ----------
  wrap.addEventListener('gesturestart', e => e.preventDefault());
  wrap.addEventListener('gesturechange', e => e.preventDefault());
  wrap.addEventListener('gestureend', e => e.preventDefault());

  wrap.addEventListener('touchstart', onTouchStart, {passive:false});
  wrap.addEventListener('touchmove', onTouchMove, {passive:false});
  wrap.addEventListener('touchend', onTouchEnd, {passive:false});
  wrap.addEventListener('touchcancel', onTouchEnd, {passive:false});

  function posFromTouch(t) {
    const rect = wrap.getBoundingClientRect();
    return { x: (t.clientX - rect.left) * (window.devicePixelRatio||1), y: (t.clientY - rect.top) * (window.devicePixelRatio||1) };
  }
  function midpoint(t1, t2) {
    return { x: (t1.x + t2.x)/2, y: (t1.y + t2.y)/2 };
  }
  function dist(a,b) {
    const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);
  }

  function onTouchStart(e) {
    e.preventDefault();
    closePanels(); // 안전상: 패널이 열려 있으면 자동 닫기
    const t = e.touches;
    if (t.length === 2) {
      const p1 = posFromTouch(t[0]), p2 = posFromTouch(t[1]);
      pinch = {
        startDist: dist(p1,p2),
        startScale: scale,
        screenMid: midpoint(p1,p2),
        worldMid: screenToWorld(midpoint(p1,p2)),
      };
      tapCandidate = null;
      isPanning = false;
    } else if (t.length === 1) {
      lastTouch = posFromTouch(t[0]);
      isPanning = true;
      tapCandidate = {start: lastTouch, time: performance.now()};
    }
  }

  function onTouchMove(e) {
    e.preventDefault();
    const t = e.touches;
    if (t.length === 2 && pinch) {
      const p1 = posFromTouch(t[0]), p2 = posFromTouch(t[1]);
      const newDist = dist(p1,p2);
      let newScale = clamp(pinch.startScale * (newDist / pinch.startDist), MIN_SCALE, MAX_SCALE);
      // Keep the worldMid anchored at current screen midpoint
      const midNow = midpoint(p1,p2);
      scale = newScale;
      translateX = midNow.x - scale * pinch.worldMid.x;
      translateY = midNow.y - scale * pinch.worldMid.y;
      render();
    } else if (t.length === 1 && isPanning && lastTouch) {
      const cur = posFromTouch(t[0]);
      const dx = cur.x - lastTouch.x;
      const dy = cur.y - lastTouch.y;
      translateX += dx;
      translateY += dy;
      lastTouch = cur;
      if (tapCandidate && (Math.abs(dx) + Math.abs(dy) > 10)) tapCandidate = null; // moved too much: not a tap
      render();
    }
  }

  function onTouchEnd(e) {
    e.preventDefault();
    if (pinch && e.touches.length < 2) pinch = null;
    if (e.touches.length === 0) isPanning = false;

    // Double-tap zoom 방지
    const now = performance.now();
    if (now - lastTapTime < 350) { lastTapTime = now; return; }
    lastTapTime = now;

    // Tap handling for label place / delete
    if (tapCandidate) {
      const duration = now - tapCandidate.time;
      if (duration < 300) {
        const screenPt = tapCandidate.start;
        const worldPt = screenToWorld(screenPt);
        if (deleteMode) {
          const hit = hitTest(screenPt);
          if (hit) {
            labels = labels.filter(l => l.id !== hit.id);
            render(); save();
            showToast('라벨 삭제');
          }
        } else if (pendingLabel) {
          labels.push({ id: crypto.randomUUID(), text: pendingLabel, x: worldPt.x, y: worldPt.y });
          render(); save();
        }
      }
      tapCandidate = null;
    }
  }

  function hitTest(screenPt) {
    // Hit by screen distance threshold
    for (let i=labels.length-1; i>=0; i--) {
      const L = labels[i];
      const s = worldToScreen({x:L.x,y:L.y});
      const d = Math.hypot(s.x - screenPt.x, s.y - screenPt.y);
      if (d < 28) return L;
    }
    return null;
  }

  // Buttons / Panels
  btnDate.addEventListener('click', () => openPanel(panelDate));
  btnFeature.addEventListener('click', () => openPanel(panelFeature));
  toggleDeleteBtn.addEventListener('click', () => {
    deleteMode = !deleteMode; updateModePill();
    showToast(deleteMode ? '개별삭제: ON' : '개별삭제: OFF');
    closePanels();
  });
  resetViewBtn.addEventListener('click', () => {
    fitView(); render(); closePanels();
  });
  clearAllBtn.addEventListener('click', () => {
    if (confirm('모든 라벨을 삭제할까요?')) { labels = []; render(); save(); closePanels(); }
  });

  exportPngBtn.addEventListener('click', async () => {
    if (!imgLoaded) { showToast('사진을 먼저 불러오세요'); return; }
    const out = document.createElement('canvas');
    out.width = img.naturalWidth; out.height = img.naturalHeight;
    const cx = out.getContext('2d');
    cx.drawImage(img, 0, 0);
    // Draw labels in world coords
    for (const L of labels) {
      drawLabelOn(cx, L.x, L.y, L.text);
    }
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = 'labels.png';
    document.body.appendChild(a); a.click(); a.remove();
  });

  function drawLabelOn(cx, x, y, text) {
    cx.save();
    cx.font = 'bold 36px -apple-system, BlinkMacSystemFont, Roboto, "Noto Sans KR", Arial';
    cx.textBaseline = 'middle'; cx.textAlign = 'center';
    const padX = 16, padY = 12;
    const w = cx.measureText(text).width + padX*2;
    const h = 52;
    const r = 22;
    const left = x - w/2, top = y - h/2, right = left + w, bottom = top + h;

    cx.beginPath();
    cx.moveTo(left+r, top);
    cx.arcTo(right, top, right, bottom, r);
    cx.arcTo(right, bottom, left, bottom, r);
    cx.arcTo(left, bottom, left, top, r);
    cx.arcTo(left, top, right, top, r);
    cx.closePath();
    cx.fillStyle = 'rgba(13,110,253,0.9)';
    cx.fill();
    cx.lineWidth = 4; cx.strokeStyle = 'rgba(255,255,255,0.9)';
    cx.stroke();
    cx.fillStyle = '#fff';
    cx.fillText(text, x, y);
    cx.restore();
  }

  exportJsonBtn.addEventListener('click', () => {
    const data = { labels, worldW, worldH };
    const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'labels.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });
  importJsonBtn.addEventListener('click', async () => {
    const input = document.createElement('input');
    input.type = 'file'; input.accept = 'application/json';
    input.onchange = async () => {
      const f = input.files?.[0]; if (!f) return;
      const txt = await f.text();
      try {
        const data = JSON.parse(txt);
        labels = Array.isArray(data.labels) ? data.labels : [];
        render(); save(); closePanels();
      } catch(e) { alert('JSON 형식 오류'); }
    };
    input.click();
  });

  // Autosave / restore
  function save() {
    const data = {
      labels, scale, translateX, translateY,
      worldW, worldH, imgLoaded
    };
    localStorage.setItem(stateKey, JSON.stringify(data));
  }
  function restore() {
    try {
      const s = localStorage.getItem(stateKey);
      if (!s) return;
      const data = JSON.parse(s);
      labels = data.labels || [];
      scale = data.scale || 1;
      translateX = data.translateX || 0;
      translateY = data.translateY || 0;
      worldW = data.worldW || worldW;
      worldH = data.worldH || worldH;
      // 배경 이미지는 보안상 저장하지 않음. (사용자가 같은 사진을 다시 불러오면 좌표는 그대로 맞습니다)
    } catch {}
  }

  // Init
  resizeCanvas();
  restore();
  fitView();
  render();
  updateModePill();

  // Prevent double-tap zoom globally on wrap
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function (e) {
    const now = performance.now();
    if (now - lastTouchEnd <= 350) e.preventDefault();
    lastTouchEnd = now;
  }, {passive:false});

  // Panel toggles
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closePanels();
  });
})();
</script>
</body>
</html>